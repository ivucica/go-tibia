<html>
  <head>
    <meta charset="utf-8" />
    <title>gotwebfe</title>
    <meta name="theme-color" content="#444444"><!-- keep in sync with manifest -->
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="go-tibia-192.png">
    <script src="wasm_exec.js"></script>
    <script type="text/javascript">

      function progress({loaded, total}) {
          if(document.getElementById('installProgress')) {
              document.getElementById('installProgress').max = total;
              document.getElementById('installProgress').value = loaded;
              document.getElementById('installProgress').innerHTML = Math.round(loaded/total*100) + '% (' + loaded + '/' + total + ')';
          }
          if(document.getElementById('installProgressText')) {
              document.getElementById('installProgressText').innerHTML = Math.round(loaded/total*100) + '% (' + loaded + '/' + total + ')';
          }
          console.log("Loading progress: ", loaded, "/", total)
      }

      if (navigator.serviceWorker != null) {
          navigator.serviceWorker.addEventListener('message', event => progress(event.data))
          navigator.serviceWorker.register('/sw.js', {'scope': '/'})
              .then(function(registration) {
                  console.log('Registered events at scope: ', registration.scope);

                  // TODO: return registration.pushManager.getSubscription(), and on that .then(function(subscription)) where if !subscription, subscribe, else register with the server with xmlhttprequest
                  // to subscribe, navigator.serviceWorker.ready.then(function(registration) { return registration.pushManager.subscribe({userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(pubkey)})}).then(function(subscription) {  /* push using xmlhttprequest */ }), and finally .catch(err => console.error(err)) or whatever
                  // Idea: do this in a separate .js file which can be generated from a template, and thus include the vapid keys.
                  // Service worker should self.addEventListener("push", functionhere) where the function uses event.data.text() and event.waitUntil(self.registration.showNotification(title, options={body:event.data.text()})) or something

                  // In general it might be nicer to rework this based on navigator.serviceWorker.ready.then(...) approach.
                  //
                  // Also, the above assumes immediate registration for notifications. A better approach would be to offer a UI element to start receiving notifications.
                  // Presumably it would then call navigator.serviceWorker.ready.then(...) in the UI element.

                  registration.addEventListener('updatefound', function() {

                      document.getElementById('install').innerHTML = (
                          '<div class="titlebar">Installing an update...</div>' +
                              '<div class="content">' +
                                  '<progress name="installProgress" id="installProgress"></progress>' +
                                  '<label for="installProgress" class="panelfont" style="user-select: none;" id="installProgressText"></label>' +
                              '</div>' +
                          '<div class="bottombar"></div>')




                      // document.getElementById('install').style.height = '100px';

                      const updatedWorker = registration.installing;
                      updatedWorker.addEventListener('statechange', function() {
                          if (updatedWorker.state === 'installed') {
                              document.getElementById('install').innerHTML = (
                                  '<div class="titlebar">New update installed</div>' +
                                      '<div class="content">' +
                                        '<div class="panelfont" style="color: rgb(40%, 100%, 40%); user-select: none;" id="installProgressText">Push the button to complete the install.</div>' +
                                        '<button onclick="location.reload()"><div>Reload</div></button>' +
                                      '</div>' +
                                      '<div class="bottombar"></div>')
                          }
                          if (updatedWorker.state === 'redundant') {
                              document.getElementById('install').innerHTML = (
                                  '<div class="titlebar">Another update is already ready</div>' +
                                      '<div class="content">' +
                                        '<div class="panelfont" style="user-select: none;" id="installProgressText">Push the button to start a new update.</div>' +
                                        '<button onclick="location.reload()"><div>Reload</div></button>' +
                                      '</div>' +
                                      '<div class="bottombar"></div>')
                          }
                      });
                  });
              })
              .catch(function(error) {
                  console.error('Service worker registration failed:', error)
              });
          if (navigator.serviceWorker.controller) {
              console.log(`Currently controlled by a service worker: ${navigator.serviceWorker.controller}`)
          }
      } else {
          console.warn('Service workers not supported.')
      }
    </script>
    <script>
      // FIXME: wait until serviceworker is available, otherwise both sw
      // and wasm will be fetching the file.

      if (WebAssembly) {
        // WebAssembly.instantiateStreaming is not currently available in Safari
        if (WebAssembly && !WebAssembly.instantiateStreaming) { // polyfill
          WebAssembly.instantiateStreaming = async (resp, importObject) => {
            const source = await (await resp).arrayBuffer();
            return await WebAssembly.instantiate(source, importObject);
          };
        }

        const go = new Go();
        WebAssembly.instantiateStreaming(
          fetch('main.wasm'),
          go.importObject
        ).then(result => {
          go.run(result.instance)
        })
      } else {
         console.log("WebAssembly is not supported in your browser")
      }
    </script>
    <link rel="stylesheet" href="tfont.css">
  </head>
  <body>
    <!--
    <div class="titleshadow">
      <h1>gotwebfe</h1>
    </div>
    -->

    <div class="window-controls-overlay panelfont" id="window-controls-overlay">
      <div class="titlebar" id="window-controls-titlebar">
        <!-- todo: move inline style into css -->
        <div class="titlebar-icon" id="window-controls-icon" style="display: inline; height: 100%; position: relative;">
          <img src="/creature/203-2-0" class="titlebar-icon" id="window-controls-icon" width="16" height="16" align="center" style="left: -3px; top: 0px; position: absolute;"><!-- titlebar height is presumably 17px in css -->
        </div>
        <div style="display: inline-block; width: 16px;"></div><!-- todo: combine with above so space is correctly taken -->
        Go-Tibia

        <div class="button-area" >
          <button class="button"><div>inactive button</div></button>
        </div>
      </div>
      <script>
        /* this mostly-unused block mostly from: https://web.dev/window-controls-overlay/ */
        var div = document.getElementById('window-controls-titlebar');
        if ('windowControlsOverlay' in navigator) {
            // Window Controls Overlay is supported.
            console.log('window controls overlay enabled');


            const { x } = navigator.windowControlsOverlay.getTitlebarAreaRect();
            // Window controls are on the right (like on Windows).
            // Chrome menu is left of the window controls.
            // [ windowControlsOverlay___________________ […] [_] [■] [X] ]
            if (x === 0) {
                div.classList.add('window-controls-right');
            }
            // Window controls are on the left (like on macOS).
            // Chrome menu is right of the window controls overlay.
            // [ [X] [_] [■] ___________________windowControlsOverlay [⋮] ]
            else {
                div.classList.add('window-controls-left');
            }
        } else {
            // When running in a non-supporting browser tab.
            div.classList.add('window-controls-right');
        }

        if (navigator.windowControlsOverlay.visible) {
            // The window controls overlay is visible in the title bar area.
        }

        // Create the query list.
        const mediaQueryList = window.matchMedia('(display-mode: window-controls-overlay)');

        // Define a callback function for the event listener.
        function handleDisplayModeChange(mql) {
            // React on display mode changes.
            console.log('orientation changed');
        }

        // Run the display mode change handler once.
        handleDisplayModeChange(mediaQueryList);

        // Add the callback function as a listener to the query list.
        mediaQueryList.addEventListener('change', handleDisplayModeChange);


        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        if ('windowControlsOverlay' in navigator) {
            //navigator.windowControlsOverlay.ongeometrychange = debounce((e) => {
            //    span.hidden = e.titlebarAreaRect.width < 800;
            //}, 250);
        }
        navigator.windowControlsOverlay.addEventListener(
            'geometrychange',
            debounce((e) => {
                //span.hidden = e.titlebarAreaRect.width < 800;
            }, 250),
        );

      </script>
    </div>

    <div class="window-controls-overlay-content-spacing"></div>

    <!-- populated from jsglobal_js.go -->
    <div id="share-target-container"></div>

    <div class="window" style="margin-left: auto; margin-right: auto; width: 250px; height: 100px;" id="install">
      <div class="titlebar">gotwebfe</div>
      <div class="content">
        <div class="panelfont" style="user-select: none;" id="installProgressText">Running</div>
      </div>
      <div class="bottombar"></div>
    </div>


    <div style="padding: 30px; width: 700px; height: 900px; margin-left: auto; margin-right: auto;">
      <div class="window" style="margin-left: auto; margin-right: auto; width: 250px; height: 150px;">
        <div class="titlebar">Sprites</div>
        <div class="content">
          <p>
            <input type="text" id="sprite_id" placeholder="sprite id"><button onclick="showSpr(parseInt(document.getElementById('sprite_id').value));"><div>show</div></button>
          </p>
          <div id="sprites" style="min-height: 50px;">
          </div>
        </div>

        <div class="bottombar"></div>
      </div>

      <div class="window" style="margin-left: auto; margin-right: auto; width: 600px; height: 550px;">
        <div class="titlebar">Map</div>
        <div class="content">
          <div id="map">
          </div>
          <p style="user-select: none;">
            <button onclick="loaderPromise().then((val) => console.log('loading complete'))"><div>loaderPromise</div></button>
            <button onclick="loaderPromise().then(showMap, (val) => console.error('loading failed: ' + val))"><div>show map</div></button>
            <button onclick="loaderPromise().then((val) => showMap())"><div>show map 2</div></button>
            <button onclick="addX(); document.getElementById('mapProgress').style.visibility = 'inherit'; setTimeout(_ => loaderPromise().then((val) => showMap()).then(() => document.getElementById('mapProgress').style.visibility = 'hidden'), 0)"><div>X+</div></button>
            <button onclick="addY(); document.getElementById('mapProgress').style.visibility = 'inherit'; setTimeout(_ => loaderPromise().then((val) => showMap()).then(() => document.getElementById('mapProgress').style.visibility = 'hidden'), 0)"><div>Y+</div></button>
            <button onclick="subX(); document.getElementById('mapProgress').style.visibility = 'inherit'; setTimeout(_ => loaderPromise().then((val) => showMap()).then(() => document.getElementById('mapProgress').style.visibility = 'hidden'), 0)"><div>X-</div></button>
            <button onclick="subY(); document.getElementById('mapProgress').style.visibility = 'inherit'; setTimeout(_ => loaderPromise().then((val) => showMap()).then(() => document.getElementById('mapProgress').style.visibility = 'hidden'), 0)"><div>Y-</div></button>
            <button onclick="document.getElementById('map').classList.toggle('isometric');"><div>iso</div></button>
            <br>
          <progress id="mapProgress" style="visibility: hidden;"></progress>
          </p>
        </div>

        <div class="bottombar"></div>
      </div>

      <div class="window" style="margin-left: auto; margin-right: auto; width: 250px; height: 70px;">
        <div class="titlebar">Maintenance</div>
        <div class="content">
          <p>
            <button onclick="navigator.serviceWorker.getRegistrations().then(function(registrations) { for(let registration of registrations) {  registration.unregister()} })"><div>clear service worker</div></button>
            <button onclick="caches.keys().then((k) => k.map(function(key) { return caches.delete(key) }))"><div>clear caches</div></button>
          </p>
        </div>  
        <div class="bottombar"></div>
      </div>


  </body>
  
</html>
