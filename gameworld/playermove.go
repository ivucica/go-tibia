package gameworld

import (
	"encoding/binary"
	"fmt"

	tnet "badc0de.net/pkg/go-tibia/net"
	"badc0de.net/pkg/go-tibia/things"

	"github.com/golang/glog"
)

// playerCancelMove tells the client to cancel the player's move in the given
// direction.
func (c *GameworldConnection) playerCancelMove(dir byte) error {
	pid, err := c.PlayerID()
	if err != nil {
		return err
	}
	player, err := c.server.mapDataSource.GetCreatureByID(pid)
	if err != nil {
		return err
	}
	player.SetDir(things.CreatureDirection(dir))

	out := tnet.NewMessage()
	out.Write([]byte{0xB5})
	out.Write([]byte{
		dir, // direction
	})
	c.senderChan <- out
	return nil
}

// playerMoveNorth tells the client to move the player north by one tile. The
// actual network traffic is generated by playerMoveNorthImpl.
func (c *GameworldConnection) playerMoveNorth() error {
	outMove := tnet.NewMessage()
	if err := c.playerMoveNorthImpl(outMove); err != nil {
		return err
	}

	c.senderChan <- outMove
	return nil
}

// playerMoveEast tells the client to move the player east by one tile. The
// actual network traffic is generated by playerMoveEastImpl.
func (c *GameworldConnection) playerMoveEast() error {
	outMove := tnet.NewMessage()
	if err := c.playerMoveEastImpl(outMove); err != nil {
		return err
	}

	c.senderChan <- outMove
	return nil
}

// playerMoveSouth tells the client to move the player south by one tile. The
// actual network traffic is generated by playerMoveSouthImpl.
func (c *GameworldConnection) playerMoveSouth() error {
	outMove := tnet.NewMessage()
	if err := c.playerMoveSouthImpl(outMove); err != nil {
		return err
	}

	c.senderChan <- outMove
	return nil
}

// playerMoveWest tells the client to move the player west by one tile. The
// actual network traffic is generated by playerMoveWestImpl.
func (c *GameworldConnection) playerMoveWest() error {
	outMove := tnet.NewMessage()
	if err := c.playerMoveWestImpl(outMove); err != nil {
		return err
	}

	c.senderChan <- outMove
	return nil
}

// moveCreature moves a creature from its current position to a new position,
// and generates the network traffic to inform the client of the move. The
// player's position is updated in the data source, and the creature is removed
// from the old tile and added to the new tile.
func (c *GameworldConnection) moveCreature(outMove *tnet.Message, player Creature, newP tnet.Position) error {
	p := player.GetPos()
	pid := player.GetID()

	outMove.Write([]byte{0x6D})

	// write old position to message
	if err := binary.Write(outMove, binary.LittleEndian, p); err != nil {
		return err
	}
	// get source tile
	t, err := c.server.mapDataSource.GetMapTile(p.X, p.Y, p.Floor)
	if err != nil {
		return err
	}

	// find source index for creature.

	// first, count items.
	var itemCount int
	for itemCount = 0; ; itemCount++ {
		// TODO(ivucica): this loop is really silly; expose item count in tile interface
		_, err := t.GetItem(itemCount)
		if err == ItemNotFound {
			break
		}
		if err != nil {
			return err
		}
	}
	// now, find the creature.
	for i := 0; ; i++ {
		// TODO(ivucica): allow fetching item stackindex using tile interface
		c, err := t.GetCreature(i)
		if err == CreatureNotFound {
			return fmt.Errorf("creature not found at expected tile (%v / %v)", p, t)
		}
		if err != nil {
			return err
		}
		if c.GetID() == pid {
			outMove.Write([]byte{byte(i + itemCount)})
			glog.Infof("moving from stackpos %d", i+itemCount)
			break
		}
	}

	// remove creature from source tile
	if err := t.RemoveCreature(player); err != nil {
		return err
	}

	// apply new position to player creature on the server side
	if err := player.SetPos(newP); err != nil {
		return err
	}
	// write new position to message
	if err := binary.Write(outMove, binary.LittleEndian, newP); err != nil {
		return err
	}

	// get destination tile
	t, err = c.server.mapDataSource.GetMapTile(newP.X, newP.Y, newP.Floor)
	if err != nil {
		return err
	}
	// add player creature to the destination tile
	if err := t.AddCreature(player); err != nil {
		return err
	}

	return nil
}

// TestOnly_PlayerMoveNorthImpl is a test-only function that allows testing the
// playerMoveNorthImpl function. It is not meant to be exported, and is only
// used for testing.
func (c *GameworldConnection) TestOnly_PlayerMoveNorthImpl(outMove *tnet.Message) error {
	return c.playerMoveNorthImpl(outMove)
}

// playerMoveNorthImpl moves the player north by one tile. It generates the
// network traffic to move the player, and returns an error if the move could
// not be completed. Player's direction is updated to point to north.
//
// The map description is also sent to the client; the kind of map description
// sent is indicated by the message type, 0x65, which indicates we need to send
// the tiles starting from X=player.X-viewSizeW/2+1, Y=player.Y-viewSizeH/2+1,
// of size viewSizeW x 1. (This is the top edge of the new viewport.)
func (c *GameworldConnection) playerMoveNorthImpl(outMove *tnet.Message) error {
	pid, err := c.PlayerID()
	if err != nil {
		return err
	}
	player, err := c.server.mapDataSource.GetCreatureByID(pid)
	if err != nil {
		return err
	}
	p := player.GetPos()

	newP := tnet.Position{X: p.X, Y: p.Y - 1, Floor: p.Floor}
	if err := c.moveCreature(outMove, player, newP); err != nil {
		return err
	}
	player.SetDir(things.CreatureDirectionNorth)

	glog.Infof("oldpos is %v", p)
	glog.Infof("newpos is %v", newP)

	///////////////////////////

	//outMap := tnet.NewMessage()
	outMap := outMove
	outMap.Write([]byte{0x65}) // move north desc

	pos := newP

	startX := pos.X - uint16(c.viewportSizeW()/2-1)
	startY := pos.Y - uint16(c.viewportSizeH()/2-1)

	glog.Infof("playerMoveNorth for player %d at %d %d %d", pid, pos.X, pos.Y, pos.Floor)

	err = c.mapDescription(outMap, startX, startY, int8(pos.Floor), uint16(c.viewportSizeW()), 1)

	return err
}

// playerMoveEastImpl moves the player east by one tile. It generates the
// network traffic to move the player, and returns an error if the move could
// not be completed. Player's direction is updated to point to east.
//
// The map description is also sent to the client; the kind of map description
// sent is indicated by the message type, 0x66, which indicates we need to send
// the tiles starting from X=player.X+viewSizeW/2, Y=player.Y-viewSizeH/2+1, of
// size viewSizeW x 1. (This is the right edge of the new viewport.)
func (c *GameworldConnection) playerMoveEastImpl(outMove *tnet.Message) error {
	pid, err := c.PlayerID()
	if err != nil {
		return err
	}
	player, err := c.server.mapDataSource.GetCreatureByID(pid)
	if err != nil {
		return err
	}
	p := player.GetPos()

	newP := tnet.Position{X: p.X + 1, Y: p.Y, Floor: p.Floor}
	if err := c.moveCreature(outMove, player, newP); err != nil {
		return err
	}
	player.SetDir(things.CreatureDirectionEast)

	glog.Infof("oldpos is %v", p)
	glog.Infof("newpos is %v", newP)

	///////////////////////////

	//outMap := tnet.NewMessage()
	outMap := outMove
	outMap.Write([]byte{0x66}) // move east desc

	pos := newP

	startX := pos.X + uint16(c.viewportSizeW()/2)
	startY := pos.Y - uint16(c.viewportSizeH()/2-1)

	glog.Infof("playerMoveEast for player %d at %d %d %d", pid, pos.X, pos.Y, pos.Floor)

	err = c.mapDescription(outMap, startX, startY, int8(pos.Floor), 1, uint16(c.viewportSizeH()))

	return err
}

// playerMoveSouthImpl moves the player south by one tile. It generates the
// network traffic to move the player, and returns an error if the move could
// not be completed. Player's direction is updated to point to south.
//
// The map description is also sent to the client; the kind of map description
// sent is indicated by the message type, 0x67, which indicates we need to send
// the tiles starting from X=player.X-viewSizeW/2+1, Y=player.Y+viewSizeH/2, of
// size viewSizeW x 1. (This is the bottom edge of the new viewport.)
func (c *GameworldConnection) playerMoveSouthImpl(outMove *tnet.Message) error {
	pid, err := c.PlayerID()
	if err != nil {
		return err
	}
	player, err := c.server.mapDataSource.GetCreatureByID(pid)
	if err != nil {
		return err
	}
	p := player.GetPos()

	newP := tnet.Position{X: p.X, Y: p.Y + 1, Floor: p.Floor}
	if err := c.moveCreature(outMove, player, newP); err != nil {
		return err
	}
	player.SetDir(things.CreatureDirectionSouth)

	glog.Infof("oldpos is %v", p)
	glog.Infof("newpos is %v", newP)

	///////////////////////////

	//outMap := tnet.NewMessage()
	outMap := outMove
	outMap.Write([]byte{0x67}) // move south desc

	pos := newP

	startX := pos.X - uint16(c.viewportSizeW()/2-1)
	startY := pos.Y + uint16(c.viewportSizeH()/2)

	glog.Infof("playerMoveSouth for player %d at %d %d %d", pid, pos.X, pos.Y, pos.Floor)

	err = c.mapDescription(outMap, startX, startY, int8(pos.Floor), uint16(c.viewportSizeW()), 1)

	return err
}

// playerMoveWestImpl moves the player west by one tile. It generates the
// network traffic to move the player, and returns an error if the move could
// not be completed. Player's direction is updated to point to west.
//
// The map description is also sent to the client; the kind of map description
// sent is indicated by the message type, 0x68, which indicates we need to send
// the tiles starting from X=player.X-viewSizeW/2+1, Y=player.Y-viewSizeH/2+1, of
// size 1 x viewSizeH. (This is the left edge of the new viewport.)
func (c *GameworldConnection) playerMoveWestImpl(outMove *tnet.Message) error {
	pid, err := c.PlayerID()
	if err != nil {
		return err
	}
	player, err := c.server.mapDataSource.GetCreatureByID(pid)
	if err != nil {
		return err
	}
	p := player.GetPos()

	newP := tnet.Position{X: p.X - 1, Y: p.Y, Floor: p.Floor}
	if err := c.moveCreature(outMove, player, newP); err != nil {
		return err
	}
	player.SetDir(things.CreatureDirectionWest)

	glog.Infof("oldpos is %v", p)
	glog.Infof("newpos is %v", newP)

	///////////////////////////

	//outMap := tnet.NewMessage()
	outMap := outMove
	outMap.Write([]byte{0x68}) // move west desc

	pos := newP

	startX := pos.X - uint16(c.viewportSizeW()/2-1)
	startY := pos.Y - uint16(c.viewportSizeH()/2-1)

	glog.Infof("playerMoveWest for player %d at %d %d %d", pid, pos.X, pos.Y, pos.Floor)

	err = c.mapDescription(outMap, startX, startY, int8(pos.Floor), 1, uint16(c.viewportSizeH()))

	return err
}
